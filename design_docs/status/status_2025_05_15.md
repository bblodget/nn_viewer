# SchematicViewer Status Update - May 15, 2025

## Overview

We've completed a major update to the diagram format specification (v2), which includes significant enhancements to support more flexible and reusable module definitions. The format changes are substantial enough that a complete rewrite of the core rendering engine is recommended.

## Completed Work

1. **Enhanced Format Specification**:
   - Updated `diagram_format_v2.md` with unified primitive/module architecture
   - Added support for parameterized modules and components
   - Implemented port grouping and arrangement options
   - Added component loops for dynamic component generation
   - Created expression syntax for dynamic values and conditional logic
   
2. **Example Updates**:
   - Updated `json/mac_block.json` to demonstrate the new format
   - Added parameterized delay_chain module example
   - Implemented port groups for inputs and weights
   - Converted multiple registers to use component loops

## Design Decisions

1. **Unified Component Model**:
   - Both primitives and modules use the same instantiation interface
   - Components are distinguished by the `is_primitive` flag in their definition
   - All components (primitive or module) are instantiated the same way

2. **Parameter System**:
   - Module definitions can include parameters with default values
   - Component instantiations can override parameters
   - Parameters can be referenced using `${PARAM_NAME}` syntax
   - Expressions support arithmetic, comparisons, and conditionals

3. **Port Organization**:
   - Ports can be grouped for organizational and visual purposes
   - Groups can specify arrangement patterns (interleaved, sequential, etc.)
   - Port sizes can be parameterized, enabling flexible bit-width configurations

4. **Component Generation**:
   - Component loops allow repetitive structures to be generated
   - Dynamic component IDs and connections based on iterator values
   - Conditional output mappings with expression support

5. **Module Layout**:
   - Module width is determined by latency (not user-configurable)
   - Height can be customized for better port spacing
   - Added a compression mode toggle for compact visualization

## Implementation Plan

Due to the significant architectural changes, we plan to rewrite the renderer from scratch rather than trying to adapt the existing code. The implementation will be phased:

### Phase 1: Core Architecture
- Implement basic module/primitive registry system
- Create parameter resolution and expression evaluation engine
- Build fundamental rendering of primitives and simple modules

### Phase 2: Advanced Features
- Implement port groups and arrangement algorithms
- Add component loop processing and dynamic component generation
- Develop module navigation system 

### Phase 3: Layout and Visualization
- Create the automatic layout engine with clock cycle positioning
- Implement module compression mode
- Add visual customization features like colors and custom labels

### Phase 4: User Interface
- Develop module navigation interface
- Add compression toggle controls
- Implement zooming and panning

## Next Steps

1. Begin the rewrite of the core rendering engine based on v2 format
2. Create validators and processors for the new format features
3. Develop an expression evaluation engine for parameter substitution
4. Implement the component loop generator

## Open Questions

1. Should expression evaluation be done at load time or runtime?
2. How should we handle errors in expression evaluation?
3. Should we implement parameter scope inheritance from parent to child modules?
4. What visual indicators should be used for multi-bit signals?